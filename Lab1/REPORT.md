# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Калугин К.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |       3       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

Добавьте реализацию предиката 1.2 через стандартные

## Введение

Списки в языке Пролог являются, хоть и достаточно полезным, но сложным инструментом. Их использование бывает не интуитивно понятно, как, например, в случае векторов и массивов в Си ++. Кроме того, списки Пролога менее функциональны. Програмист не может легко и просто обратиться к элементу списка по значению, или, например, добавить элемент в конец списка, тогда как в большинстве императивных языков такие действия требуют не более одной команды. Из общеизвестных структур хранения данных ближе всего к списку находится стек. Точно так же как и в списке, мы можем получить доступ к верхнему (первому) элементу стека, и разделить его на, собственно, этот элемент и остальной стек.

## Задание 1.1: Собственная реализация стандартных предикатов

`llength(X, Y)` - предикат подсчета длинны список

Примеры использования:
```prolog
?- llength([1, 2, 3], N).
N = 3.
?- llength([4], 1).
true.
```

Реализация:
```prolog
llength([], 0).
llength([_|TAIL], N) :- llength(TAIL, K), N is K + 1.
```

`lmember(X, Y)` - предикат проверки принадлежности элемента к списку

Примеры использования:
```prolog
?- lmember(8, [3, 2, 8]).
true.
?- lmember(5, [3, 2, 8]).
false.
```

Реализация:
```prolog
lmember([], _) :- false.
lmember([HEAD|TAIL],M) :- HEAD = M; lmember(TAIL, M).
```

`lappend(X, Y, Z).` - предикат конкатенации двух списков

Примеры использования:
```
?- lappend([1, 2], [3, 4], R).
R = [1, 2, 3, 4].
?- lappend([1, 2], B, [1, 2, 4]).
B = [4].
```

Реализация:
```
lappend([], Y, Y).
lappend([XHEAD|XTAIL], Y, [XHEAD|Z]) :- lappend(XTAIL, Y, Z).
```

`lremove(X, Y, Z)` - предикат удаления элемента из списка по значению

Примеры использования:
```
?- lremove(4, [3, 4, 7], R).
R = [3, 7].
```

Реализация:
```
lremove(X, [X|TAIL], TAIL).
lremove(X, [Y|TAIL], [Y|TAIL1]) :- lremove(X, TAIL, TAIL1).
```

`lpermute(X, Y)` - предикат выдающий все возможные перестановки элементов списка

Примеры использования:
```
?- lpermute([1, 9], A).
A = [1, 9] ;
A = [9, 1] ;
false.
```

Реализация:
```
lpermute([],[]).
lpermute(L, [X|TAIL]) :- lremove(X, L, R), lpermute(R, TAIL).
```

`lsublist(X, Y)` - предикат проверки принадлежности подсписка списку 

Примеры использования:
```
?- lsublist([4, 9], [3, 4, 9]).
true ;
false.
?- lsublist([4, 5], [3, 4, 9]).
false.
```

Реализация:
```
lsublist(S, L) :- lappend(_, X, L), lappend(S, _, X).
```

## Задание 1.2: Предикат обработки списка

`lerase(X, Y, Z)` - предикат удаления элемента списка по номеру

Примеры использования:
```
?- lerase(2, [1, 3, 2, 4], Z).
Z = [1, 2, 4] ;
false.
```

Реализация:
```
lerase(1, [_|TAIL], TAIL). 
lerase(N, [HEAD|TAIL], [HEAD|TAIL1]) :- N1 is N - 1, lerase(N1, TAIL, TAIL1).
```

Предикат при помощи рекурсии находит такой подсписок, что элемент изначального списка с заданным номером, является головой этого подсписка, после чего удаляет ее.

## Задание 1.3: Предикат обработки числового списка

`lsum(X, Y, Z)` - предикат сложения элементов двух списков (учитывая их возможную разную длину)

Примеры использования:
```
?- lsum([1,2,3], [1,2], Z).
Z = [2, 4, 3].
```

Реализация:
```
lsum([], A, A).
lsum(A, [], A).
lsum([A|X], [B|Y], [C|Z]) :- lsum(X, Y, Z), C is A + B, !.
```

Предикат рекурсивно "разбирает" введенные списки, пока один из них не становится пустым, после чего приравнивает список-ответ непустому (либо второму, если длина списков была одинакова). После этого, предикат начинает "раскручивать рекурсию" и возвращать элементы списков на свои места, добавляя при этом их суммы в начало списка-ответа.


## Задание 2: Реляционное представление данных

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

Основные плюсы реляционного представления - это простота представления модели данных и лаконичность описания основных операций, однако существует и обратная сторона медали - доступ к данным осуществляется за достаточно большое время.  В представлении №3 строки таблицы содержат в себе полную информацию о каждом студенте. Таким образом, мы можем легко узнать, например, все оценки студента, однако узнать фамилии всех людей, принадлежащих одной группе будет уже сложнее. 

`mid_stud(A, B).` - предикат , вычисляющий средний балл каждого студента.

Примеры использования:
```
?- mid_stud(A, B).
A = 'Петров',
B = 4 ;
A = 'Петровский',
B = 3.6666666666666665 ;
A = 'Иванов',
B = 4 ;
A = 'Ивановский',
B = 3.5 ;
A = 'Запорожцев',
B = 3.5 ;
A = 'Сидоров',
B = 4 ;
A = 'Сидоркин',
B = 3.3333333333333335 ;
A = 'Биткоинов',
B = 4 ;
A = 'Эфиркина',
B = 3.8333333333333335 ;
A = 'Сиплюсплюсов',
B = 3.6666666666666665 ;
A = 'Программиро',
B = 4 ;
A = 'Джаво',
B = 4.166666666666667 ;
A = 'Клавиатурникова',
B = 3.1666666666666665 ;
A = 'Мышин',
B = 3.6666666666666665 ;
A = 'Фулл',
B = 4.333333333333333 ;
A = 'Безумников',
B = 4.333333333333333 ;
A = 'Шарпин',
B = 3.1666666666666665 ;
A = 'Круглосчиталкин',
B = 3.8333333333333335 ;
A = 'Решетников',
B = 4.166666666666667 ;
A = 'Эксель',
B = 3.8333333333333335 ;
A = 'Текстописов',
B = 3.8333333333333335 ;
A = 'Текстописова',
B = 3.6666666666666665 ;
A = 'Густобуквенникова',
B = 4.333333333333333 ;
A = 'Криптовалютников',
B = 3.6666666666666665 ;
A = 'Блокчейнис',
B = 3.5 ;
A = 'Азурин',
B = 4.333333333333333 ;
A = 'Вебсервисов',
B = 4.333333333333333 ;
A = 'Круглотличников',
B = 4.
```

Реализация:
```
mid_stud(S,Z) :- student(_, S, [grade(_, A), grade(_, B), grade(_, C), grade(_, D), grade(_, E), grade(_, F)]), Z is (A + B + C + D + E + F) / 6.
```

Предикат берет все оценки студента, складывает их и делит на количество.

`pass(A)` - предикат проверки наличия у студентов двоек

Примеры использования:
```
?- pass(A).
A = 'Петров' ;
A = 'Иванов' ;
A = 'Ивановский' ;
A = 'Биткоинов' ;
A = 'Эфиркина' ;
A = 'Сиплюсплюсов' ;
A = 'Программиро' ;
A = 'Джаво' ;
A = 'Фулл' ;
A = 'Безумников' ;
A = 'Решетников' ;
A = 'Эксель' ;
A = 'Текстописова' ;
A = 'Густобуквенникова' ;
A = 'Криптовалютников' ;
A = 'Вебсервисов' ;
A = 'Круглотличников'.
```

Реализация:
```
pass(S) :- student(_,S,A), not(member(grade(_, 2),A)).
```

Предикат проверяет у каждого студента наличие двоек и, в случае их отсутствия, выводит его фамилию.

`npass('Subject_name', A)` - предикат находящий имена студентов, не сдавших предмет.

Примеры использования:
```
?- npass('PSY', A).
A = 'Запорожцев' ;
A = 'Сидоров' ;
A = 'Мышин' ;
false.
```

Реализация:
```
npass(P,X) :- student(_, X, A), member(grade(P, B), A), B = 2.
npass(Y,X) :- subject(P, Y), npass(P, X).
```

Предикат проверяет у всех студентов наличие оценок "2" за заданный предмет и выдает их фамилии.

`all_npass('Subject_name', A)` - предикат, находящий для заданного предмета количество студентов, не сдавших его.

Примеры использования:
```
?- all_npass('LP', B).
B = 0.

?- all_npass('PSY', B).
B = 3.
```

Реализация:
```
all_npass(P,N) :- findall(X, npass(P, X), L), length(L, N).
```

Предикат находит количество студентов, получивших оценку "2" за указанный предмет. Для этого он использует предикаты 'findall' и 'npass', находя таким образом, количество решений последнего.

`all(Group_number, A).` - предикат находящий всех студентов заданной группы

Примеры использования:
```
?- all(101, A).
A = ['Петровский', 'Сидоров', 'Мышин', 'Безумников', 'Густобуквенникова'].
```

Реализация:
```
all(G, L) :- findall(F, student(G, F, _), L).
```

Предикат находит всех студентов, принадлежащих к заданной группе с помощью предиката `findall`.

`all_grop(Group_number, A).` - предикат находящий в группе студента с наивысшим средним баллом

Примеры использования:
```
?- all_grop(101, A).
A = ['Густобуквенникова'].
```

Реализация:
```
all(G, L) :- findall(F, student(G, F, _), L).
maxp([X], X, M) :- mid_stud(X, M).
maxp([X|T], Z, M) :- mid_stud(X, N), maxp(T,Y,K), (N > K -> M = N, Z = X; M = K, Z = Y).
all_grop(G,F) :- all(G,L),  findall(X, maxp(L,X,_),F).
```

Предикат находит всех студентов заданной группы с помощью предиката `all`, после чего находит их средние баллы и наибольший среди них. Фамилия студента с этим балло выводится.

## Выводы

Эта лабораторная работа стала для меня первым серьезным опытом написания программ на Прологе. Я ожидал, что мне не составит труда написать ее, однако Пролог оказался языком, абсолютно непохожим на все, встреченные мною прежде. Это достаточно сложный, в первую очередь для понимания логики работы, язык, способный, однако, просто и изящно решать весьма сложные проблемы. Таким образом, я могу заключить, что использование Пролога в определенных ситуациях существенно облегчает работу, хотя он остается достаточно узкоспециализированным языком, т.к. попытки выполнять на нем действия, присущие императивным языкам создают множество трудностей из за отсутствия(или сильного искажения) в Прологе многих инструментов, уже давно ставших привычными для програмистов, пишущих на таких языках, как Си, Питон и прочие. Ярким примером являются списки. Из-за того, что массивы(а списки, на мой взгляд, являются их заменой в прологе) больше присущи именно императивным, а не декларативным языкам - списки в прологе обладают весьма ограниченными возможностями, а следовательно, их использование является не слишком удобным. Подводя итоги, Пролог - это мощный, однако сложный для изучения язык, особенно хорошо подходящий для работы с базами данных и обработки информации.
