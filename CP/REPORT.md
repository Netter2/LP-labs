# Отчет по курсовому проекту
## по курсу "Логическое программирование"

## Введение

Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта.

Во время выполнения курсового проекта я чуть ближе познакомлюсь с языком Python, а также улучшу свой навык программирования на Prolog'е. Кроме того, я частично ознакомлюсь с темами третьей и четвертой лабораторной работы.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Опишите, как вы получили родословное дерево в формате GEDCOM, сколько в нем индивидуумов.

Воспользовавшись сайтом myHeritage я создал свое генеалогическое дерево, в которое включил своих ближайших родственников. Однако, я посчитал, что стоит увеличить количество тестовых данных для номера 3 (мой вариант требует нахождения золовок), поэтому я добавил в дерево несуществующих людей.

## Конвертация родословного дерева

Опишите, какой язык/языки вы решили использовать для решения этой задачи и почему. Опишите принцип действия программы и приведите ключевые фрагменты 
программы, позволяющие понять основные моменты решения.

Для трансляции .ged файла я решил использовать язык python, так как этот язык хорошо подходит для работы со строками. 
Алгоритм работы программы достаточно прост:

Программа находит ключевые слова в .ged файле и "вырезает" кусочки строк, в которых содержаться такие данные, как имя, фамилия и тд, после чего объединяет данные в строку, которую и записывает в файл.

## Предикат поиска родственника

Опишите, как устроен предикат поиска родственника, приведите его исходный код и примеры запросов/ответов (протокол работы).

Золовка - это родная сестра мужа. Так как мое представление использует предикат parents, то я задаю отношение "золовка" как человека, который является 

1)матерью 

2)ребенком родителей мужа(отца ребенка) второго человека. 

Как видно, если у человека нет детей, то программа не может определить его пол, а значит поиск с такими людьми работает некорректно.

```
prolog
zolovka(R2, R1) :- parents(_, H, R2), parents(H, MH, FH), parents(R1, MH, FH), parents(_, _, R1).
```

## Определение степени родства

Приведите описание метода решения, важные фрагменты исходного кода, протокол работы.

Для определения степени родства я использую 4 основных предиката.

1)rfind, выполняющий итеративный поиск всех родственных связей заданной длины
```
prolog
rfind([H|_], H, [], _).
rfind(P, G, R, C) :-
    C > 0,
    prolong(P, P1, R1, R),
    C1 is C - 1,
    rfind(P1, G, R1, C1).
```

2)relative, задающий максимальную длину родственной связи для rfind
```
prolog
relative(FR, SR, Res1) :- 
    int(CC, 1, 11),
    rfind([FR], SR, Res1, CC).

```

3)relation(A, B, C, D), предикат очищающий набор ответов от дублей
```
prolog
relation(FR, SR, R1, R2) :- 
    relative(FR, SR, Res), not(member(Res, R1)), !,
    (
        R2 = Res;
        relation(FR, SR, [Res | R1], R2)
    ).
```
4)relation(A, B, D), предикат-"обертка" для предыдущего
```
prolog
relation(FR, SR, R) :-
    relation(FR, SR, [], R).
```


## Естественно-языковый интерфейс

Моя программа способна интерпретировать несколько основных типов вопросов:

1. Who is A to B?, где A и B - это некие люди. Этот вопро вызывает стандартный предикат поиска родственников
```
?- question(['Who', 'is', 'Kirill_Kalugin', 'to', 'Ekaterina_Kalugina','?'], X).
X = [child, child, father] ;
X = [child, child, mother] ;
X = [child, child, father, child, mother] ;
X = [child, child, mother, child, father] ;
false.
```

2. How many T does A have?, где Т - это одно из ключевых слов (siblings, ancestors, children, descendants, zolovka), а А - человек, количество соответствующих родственников которого и находится при помощи нахождения количества ответов к следующему вопросу.
```
?- question(['How', 'many', 'ancestors', 'does', 'Kirill_Kalugin', 'have', '?'], X).
X = 6 ;
false.
```

3. Who are T of A?, где Т - это одно из все тех же ключевых слов, а А - человек, соответствующих родственников которого находит предикат.
```
?- question(['Who', 'are', 'ancestors', 'of', 'Kirill_Kalugin', '?'], X).
X = 'Tatyana_Kalugina' ;
X = 'Victoria_Kalugina' ;
X = 'Boris_Kalugin' ;
X = 'Aleksey_Kalugin' ;
X = 'Natalia_Kalugina' ;
X = 'Valentin_Kalugin' ;
false.
```
Все вопросы задаются строго указаной форме (то есть программа не производит полноценный языковой анализ, она лишь проверяет соответствие шаблону), в виде списка слов.

## Выводы
Курсовая работа научила меня нескольким вещам. Во-первых, язык Python оказался достаточно простым в освоении высокоуровневым языком, который хорошо подходит для работы со строками. Во-вторых, я смог приметить знания и навыки, полученные в ходе выполнения лабораторных работ, например, поиск в глубину с итеративным погружением. В-третьих, я понял, что Prolog хорошо подходит для работы с массивами данных, которые можно представить в виде базы данных, причем увеличивать эту базу можно даже алгоритмически, при помощи сторонних программ. Таким образом, курсовой проект научил меня использовать Prolog в более обширных проектах, требующих скоординированного взаимодействия нескольких программ, написанных на разных языках.
