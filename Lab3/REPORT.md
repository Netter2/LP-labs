#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

## Введение

Какие задачи удобным образом решаются методом поиска в пространстве состояний? 

Лучше всего метод поиска в пространстве состояний работает с задачами, в которых, очевидно, можно определить это пространство, а также начальные и конечные состояния, переходы от одного состояния к другому. Таким образом, это те задачи, которые можно свести к поиску решений в графе. 

Почему Prolog оказывается удобным языком для решения таких задач?

В языке Prolog очень удобно задавать состояния в виде предикатов. Кроме того, сам Prolog использует один из методов поиска - поиск в глубину. Это делает использование данного метода простым и естественным, хоть и не оптимальным.

## Задание
3. Железнодорожный сортировочный узел устроен так, как показано на
рисунке. На левой стороне собрано некоторое число вагонов двух типов
(черные и белые), обоих типов по n штук., в произвольном порядке
Тупик вмещает все 2n вагонов. Пользуясь тремя сортировочными
операциями (слева в тупик, из тупика направо, слева направо, минуя
тупик), собрать вагоны на левой стороне, так, чтобы типы чередовались.
Для решения задачи достаточно 3n-1 сортировочных операций.

## Принцип решения

Изначальное состояние описывается пользователем - это список из черных и белых вагонов, расставленных в произвольном порядке. Переходы между состояниями тоже четко определены - сдвиг вагона слева в тупик, из тупика направо и слева направо. Из - за того, что все операции двигают вагоны лишь в одном направлении, то нет необходимости создавать предохранитель от зацикливания - оно попросту невозможно. 

Я использовал следующие алгоритмы поиска - поиск в глубину, в ширину, в глубину с ограничением, в глубину с итеративным погружением.

Для каждого из них реализовано по два предиката - рабочий и "обертка".

В глубину:

Предикат - "обертка". Вызывает вспомогательный предикат goal, для получения конечного состояния и рабочий предикат dpath1.
```
prolog
dpath(X, R) :-
    goal(X, G),
    dpath1([[X, [], []]], [[], [], G], R1),
    reverse(R1, R).
```
 
Рабочий предикат. Рекурсивно вызывает вспомогательный предикат prolong, пытающийся продлить очередной путь решения.
```
prolog
dpath1([H | T], H, [H | T]).
dpath1(P, G, R) :-
   prolong(P, P1),
   dpath1(P1, G, R).
```

В ширину:

Предикат - "обертка". Использует вспомогательный предикат extra, необходимый для походового вывода решения.
```
prolog
wpath(S, R) :-
   goal(S, G),
   wpath1([[[S, [], []]]], [[], [], G], R1),
   !,
   reverse(R1, R2),
   extra(R2, R).
```
 
Рабочий предикат. Использует вспомогательный предикат mfindall, который отличается от стандартного лишь выводом пустого списка, а не "false" в случае отсутствия решений.
```
prolog
wpath1([[H | T] | _], H, [H | T]).
wpath1([H | Qin], G, R) :-
   mfindall(H, L),
   append(Qin, L, Qout),
   wpath1(Qout, G, R).
```

В глубину с ограничением глубины:

Предикат - "обертка". Находит количество вагонов и использует количество 3n - 1 в качестве ограничителя.
```
prolog
dcpath(X, R) :-
    goal(X, G),
    length(G, C1),
    C is (3 * C1 / 2) - 1,
    dcpath1([[X, [], []]], [[], [], G], R1, C), !,
    reverse(R1, R2),
    extra(R2, R).
```
 
Рабочий предикат. Выполняет поиск в глубину до тех пор, пока длина решения не превышает ограничитель.
```
prolog
dcpath1([H | T], H, [H | T], _).
dcpath1(P, G, R, C) :-
    C > 0,
    prolong(P, P1), 
    C1 is C - 1,
    dcpath1(P1, G, R, C1).
```

В глубину с итеративным погружением:

Предикат - "обертка". Как видно, поиск с итеративным погружением использует рабочий предикат поиска с ограничением глубины, однако каждый раз передает ему новое число, которое генерируется вспомогательным предикатом int.
```
prolog
dipath(X, R) :- 
    goal(X, G),
    int(CC),
    dcpath1([[X, [], []]], [[], [], G], R1, CC), !,
    reverse(R1, R2), 
    extra(R2, R).
```
 
## Результаты

Приведите результаты работы программы: найденные пути, время, затраченное на поиск тем или иным алгоритмом, длину найденного первым пути. Используйте таблицы,
если необходимо.

| Алгоритм поиска |  Длина найденного первым пути  |              Тест                 |
|-----------------|--------------------------------|-----------------------------------|
| В глубину       |12|w, w, w, w, b, b, b, b|
| В ширину        |12|w, w, w, w, b, b, b, b|
| ID              |12|w, w, w, w, b, b, b, b|
| С ограничением  |12|w, w, w, w, b, b, b, b|
||||
| В глубину       |24|b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w|
| В ширину        |-|b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w|
| ID              |24|b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w|
| С ограничением  |24|b, b, w, w, w, b, w, w, b, b, w, b, b, b, b, w, w, w|

Как видно, все виды поиска, включая поиск в глубину, всегда первым выдают кратчайший результат. Это связано с тем, что предикататы смены состояния в предикате prolong расположены в наиболее оптимальном порядке. Кроме того, при достаточно больших тестах поиск в ширину перестает работать по причине переполнения стэка памяти.

## Выводы

Данная лабораторная работа научила меня нескольким вещам. Во-первых, использование предикатов-"оберток" существенно упрощает взаимодействие пользователя с программой и предикатов друг с другом. Во-вторых, правильно написанная программа может решать задачи на поиск в пространстве состояний даже эффективнее человека, так как способна проверять абсолютно все варианты действий. Так, например, оказалось, что у моей задачи в определенных условиях может быть несколько кратчайших решений, хотя их различия минимальны. 
В-третьих, поиск с итеративным погружением в некоторых случаях (например в моем) может быть неэффективен. Это связано с тем, что длина решения в моей задаче не может быть меньше чем 2n. Таким образом, поиск с итеративным погружением находит примерно 4n^3 - 2n^2 лишних неполных решений различной длины.



