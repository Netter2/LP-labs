#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Калугин К.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Какие подходы обычно применяются для обработки естественных и искусственных языков?
Почему Prolog оказывается удобным языком для решения таких задач?

Обычно для обработки естественных и искусственных языков применяется разбитие предложения на группы слов. Каждая группа формируется по какому либо признаку. Обычно это т.н. группы существительных и группы глаголов. После определения роли слова в предложении определяется его смысл. Это делается на основе т.н. "словарей".
Пролог особенно хорошо подходит для этой задачи, тк может легко проверять принадлежность элемента к какой-либо группе (списку) припомощи предиката member.

## Задание

10. Реализовать разбор фраз языка, представляющих собой положительные и
отрицательные высказывания. В результате предикат должен выдавать все атомарные
глубинные структуры.

## Принцип решения

Опишите своими словами принцип решения задачи, приведите важные фрагменты кода. 
В начале программа отсекает первое слово предложения - это имя человека, о котором мы говорим.

```
prolog
decompose([H|T], X) :- 
    work(H ,T, X).
```

Затем оставшаяся часть разбивается так, чтобы в первой половине было предложние с имени до запятой, а во второй - с предлога до конца предложения.

```
prolog
work(H, T, X) :-
    append(L1, [HL2, _|L2], T),
    HL2 = ',',
    (
        analysis(H, L1, X);
        analysis(H, L2, X)
    ).
```

Далее происходит определение - любит человек данные вещи или же наоборот - не любит. Части содержащие в себе перечисление вещей передаются в следующий предикат.

```
prolog
analysis(H, [XH1, XH2|XT], Ans) :-
    (
        (
            XH1 = 'любит',
            deconst([XH2|XT], A),
            Ans = likes(H, A)
            
        );
        (
            XH1 = 'не',
            XH2 = 'любит',
            deconst(XT, A),
            Ans = not_likes(H, A)
        )
    ).
```

Там они анализируются и передаются в предикат, который разбивает часть вида "А и Б и В..." на названия вещей, которые человек любит (или не любит).

```
prolog
deconst(['.'], _) :- fail.
deconst([], _) :- fail.
deconst([H|T], Ans) :-
    not(H = 'и'),
    Ans = H;
    deconst(T, Ans).
```

В итоге, программа получает список вещей, с отметкой, любит ли их человек и его имя. На основе этих данных программа выдает ответ. 

## Результаты

```
prolog
?- decompose(['Петя', 'не', 'любит', 'сливы', ',', 'но', 'любит', 'яблоки', 'и', 'сливы'],X).
X = not_likes('Петя', сливы) ;
X = likes('Петя', яблоки) ;
X = likes('Петя', сливы) ;
false.

?- decompose(['Вася','любит','сливы',',','и','любит','груши'], X).
X = likes('Вася', сливы) ;
X = likes('Вася', груши) ;
false.

?- decompose(['Вася','любит','сливы','и','апельсины',',','но','не','любит','бананы','и','ананасы'],X).
X = likes('Вася', сливы) ;
X = likes('Вася', апельсины) ;
X = not_likes('Вася', бананы) ;
X = not_likes('Вася', ананасы) ;
false.
```

## Выводы

Как оказалось использование Пролога для решения задач грамматического разбора является достаточно удобным. Это связано с тем, списки и предикат append позволяют проверить все возможные разбиения списка слов, и, как следствие, найти нужное. Таким образом, Пролог способен обрабатывать различные, в том числе усложненные дополнительными словами, а не только шаблонные предложения.
